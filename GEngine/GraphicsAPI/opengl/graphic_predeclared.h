//
// Created by zhanghong50 on 2022/1/25.
//

#ifndef MYENGINE_GRAPHIC_PREDECLARED_H
#define MYENGINE_GRAPHIC_PREDECLARED_H

#include "basic_include.h"
#include "GL/glew.h"

GENG_BEGIN

#define GE_MAX_COMBINED_TEXTURE_IMAGE_UNITS GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
#define GE_MAX_TEXTURE_IMAGE_UNITS GL_MAX_TEXTURE_IMAGE_UNITS

enum ERROR_CODE{
    SHADER_UPDATE_TEXTURE_ERROR = 0
};

// buffer type 
enum GBUFFER_T {
    GE_ELEMENT_ARRAY_BUFFER = GL_ELEMENT_ARRAY_BUFFER,
    GE_ARRAY_BUFFER = GL_ARRAY_BUFFER
};

static std::map<GBUFFER_T, std::string> data_buffer_t = {
    {GE_ARRAY_BUFFER, "ARRAY_BUFFER"},
    {GE_ELEMENT_ARRAY_BUFFER, "ELEMENT_ARRAY_BUFFER"}
};

// draw call
enum GDRAW_CALL_T {
    GE_TRIANGLES = GL_TRIANGLES, 
    GE_POINTS = GL_POINTS, 
    GE_LINES = GL_LINES
};

// Shader type

enum GSHADER_T {
    GE_VERTEX_SHADER = GL_VERTEX_SHADER,
    GE_FRAGMENT_SHADER = GL_FRAGMENT_SHADER
};


// Data Draw
enum GDRAW_T {
    GE_STATIC_DRAW = GL_STATIC_DRAW,
    GE_DYNAMIC_DRAW = GL_DYNAMIC_DRAW
};

// Texture Map

enum GTEX_D {
    GE_TEXTURE_1D = GL_TEXTURE_1D, 
    GE_TEXTURE_2D = GL_TEXTURE_2D, 
    GE_TEXTURE_3D = GL_TEXTURE_3D,
    GE_TEXTURE_CUBE_MAP = GL_TEXTURE_CUBE_MAP,
    GE_TEXTURE_CUBE_MAP_POSITIVE_X = GL_TEXTURE_CUBE_MAP_POSITIVE_X, 
    GE_TEXTURE_CUBE_MAP_POSITIVE_Y = GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
    GE_TEXTURE_CUBE_MAP_POSITIVE_Z = GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
    GE_TEXTURE_CUBE_MAP_NEGATIVE_X = GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
    GE_TEXTURE_CUBE_MAP_NEGATIVE_Y = GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
    GE_TEXTURE_CUBE_MAP_NEGATIVE_Z = GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
};


enum GTEX_PARAM {
    GE_REPEAT = GL_REPEAT,
    GE_CLAMP_TO_EDGE = GL_CLAMP_TO_EDGE,
    GE_CLAMP_TO_BORDER = GL_CLAMP_TO_BORDER,
    GE_MIRRORED_REPEAT = GL_MIRRORED_REPEAT,
    GE_MIRROR_CLAMP_TO_EDGE = GL_MIRROR_CLAMP_TO_EDGE,
    GE_LINEAR = GL_LINEAR,
    GE_NEAREST = GL_NEAREST
};

enum GTEX_T {
    GE_RGB = GL_RGB,
    GE_RGBA = GL_RGBA,
    GE_RGBA16F = GL_RGBA16F,
    GE_RGBA32 = GL_RGBA32F,
    GE_DEPTH_COMPONENT = GL_DEPTH_COMPONENT,
    GE_DEPTH_STENCIL = GL_DEPTH_STENCIL
};


// GENGINE Data Type
enum GData_T {
    GE_FLOAT = GL_FLOAT,
    GE_FLOAT_VEC3 = GL_FLOAT_VEC3,
    GE_FLOAT_MAT4 = GL_FLOAT_MAT4,
    GE_SAMPLER_2D = GL_SAMPLER_2D,
    GE_SAMPLER_CUBE = GL_SAMPLER_CUBE,
    GE_UBYTE = GL_UNSIGNED_BYTE
};


// FrameBuffer
enum GATTACHMENT_T {
    GE_COLOR_ATTACHMENT0 = GL_COLOR_ATTACHMENT0,
    GE_COLOR_ATTACHMENT1 = GL_COLOR_ATTACHMENT1,
    GE_DEPTH_ATTACHMENT = GL_DEPTH_ATTACHMENT
};

static std::map<GTEX_T, GATTACHMENT_T> attachment_t = {
    {GE_RGB, GE_COLOR_ATTACHMENT0},
    {GE_RGBA, GE_COLOR_ATTACHMENT0},
    {GE_DEPTH_COMPONENT, GE_DEPTH_ATTACHMENT},
};


GENG_END

#endif //MYENGINE_GRAPHIC_PREDECLARED_H
